# -*- coding: utf-8 -*-
"""
Created on Wed Jul  6 12:50:59 2022

@author: coopy
"""
#This script provides the functionality to parse through the all_data.json 
#file generated by gc_manager and plot desired energy pathways using 
#matplotlib

###############################################################################
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
from matplotlib.patches import Patch
import numpy as np
import json
import os
import re
import pprint
H_to_ev = 27.2114

###############################################################################
# with open(os.path.join(path,json_file),'r') as f:
#     all_data = json.load(f)

class Pathway:
    def __init__(self, path=None, filename=None, reaction='N2R'):
        if path is None:
            self.path = os.getcwd()
        else:
            self.path = path
            
        if filename is None:
            self.filename = 'all_data.json'
        else:
            self.filename = filename
        self.pathways = {}
        self.count = 0
        self.reaction = reaction
        self.reaction_data = {
                            'N2R': 
                          {'pathway' : ['N2','N2H','NNH2','NNH3','N','NH','NH2','NH3'],
                          'protons' : [6, 5, 4, 3, 3, 2, 1, 0],
                          'molecules' : [{},{},{},{},{'NH3':1},{'NH3':1},{'NH3':1},{'NH3':1}],
                          'entropy' : {'N2': 0.021720172, 'NH3': 0.021830347, 
                                       'H3O': 0.021892558, 'H2O': 0.021404843},
                          'ZPE' : {'N2': 0.005677, 'NH3': 0.034492, 
                                       'H3O': 0.035438, 'H2O': 0.021586 },
                          'initial_state' : {'molecules' : {'N2' : 1},
                                             'protons' : 6,
                                             'label' : 'N2'},
                          'final_state' : {'molecules' : {'NH3' : 2},
                                             'protons' : 0,
                                             'label': 'NH3'}
                              },
                          'N2R_Montoya':
                              {'pathway' : ['N2H','NNH2','N','NH','NH2'],
                               'protons' : [5,4,3,2,1],
                               'molecules' : [{},{},{'NH3':1},{'NH3':1},{'NH3':1}],
                               'entropy' : {'N2': 0.021720172, 'NH3': 0.021830347},
                               'initial_state' : {'molecules' : {'N2' : 1},
                                                  'protons' : 6,
                                                  'label' : 'N2'},
                               'final_state' : {'molecules' : {'NH3' : 2},
                                                  'protons' : 0,
                                                  'label': 'NH3'}
                                  },
                            'N2R_alternating':
                                {'pathway' : ['N2','N2H','NHNH','NHNH2','NH2NH2','NH2','NH3'],
                                 'protons': [6,5,4,3,2,1,0],
                                 'molecules' : [{},{},{},{},{},{'NH3':1},{'NH3':1}],
                                 'entropy' : {'N2': 0.021720172, 'NH3': 0.021830347},
                                 'initial_state' : {'molecules' : {'N2' : 1},
                                                    'protons' : 6,
                                                    'label' : 'N2'},
                                 'final_state' : {'molecules' : {'NH3' : 2},
                                                    'protons' : 0,
                                                    'label': 'NH3'}
                                    },
                                
                            'N2R_dissociative': #This pathway does not actually work. It is only for extracting energies
                                {'pathway': ['N','NH','NH2','NH3'],
                                 'protons': [6,4,2,0],
                                 'molecules': [{},{},{},{}],
                                 'entropy' : {'N2': 0.021720172, 'NH3': 0.021830347},
                                 'initial_state' : {'molecules' : {'N2' : 1},
                                                    'protons' : 6,
                                                    'label' : 'N2'},
                                 'final_state' : {'molecules' : {'NH3' : 2},
                                                    'protons' : 0,
                                                    'label': 'NH3'}
                                 },
            
                            'HER':
                          {'pathway' : ['H'],
                           'protons' : [1],
                           'molecules' : [{}],
                           'entropy' : {'H3O': 0.0218925, 'H2O': 0.0214048,
                                        'H2': 0.01483246506},
                           'ZPE' : {'H3O': 0.035438, 'H2O': 0.021586,
                                    'H2': 0.010088},
                           'initial_state' : {'molecules' : None,
                                              'protons' : 2,
                                              'label' : '2H+'},
                           'final_state' : {'molecules' : {'H2' : 1},
                                              'protons' : 0,
                                              'label' : 'H2'}
                           },
                          
                          'CO2R':
                              {'pathway' : ['CO2','COOH','CO'],
                               'protons' : [2,1,0],
                               'molecules' : [{}, {}, {'H2O':1}],
                               'initial_state' : {'molecules' : {'CO2' : 1},
                                                  'protons' : 2,
                                                  'label' : 'CO2 (aq)'},
                               'final_state' : {'molecules' : {'H2O' : 1, 'CO' : 1},
                                                  'protons' : 0,
                                                  'label' : 'CO (aq)'},
                                  
                                  },
                             
                            'molecules' : {'H2O' : {'-1.00' : -16.20500972}}
            
            }
        self.potentials = {'0.00': -0.1713, '-0.25': -0.1621, '-0.50': -0.1529}
        
    def set_reaction_data(self, reaction_data_entry, reaction_name):
        self.reaction_data[reaction_name] = reaction_data_entry
        #TODO add functionality to add custom reaction_data entries
        
    def get_reaction_data(self):
        pprint.pprint(self.reaction_data)
        
    def get_materials(self):
        #returns a list of the materials input for the instance of this class
        materials = []
        for ipath in range(len(self.pathways.keys())):
            path_list = self.pathways[ipath]
            materials.append(path_list[0])
        return materials
        
    def get_json(self):
        '''
        This method will return the json as a dictionary to be investigated in 
        the IDE variable pane
        '''
        with open(os.path.join(self.path,self.filename),'r') as f:
            all_data = json.load(f)
        return all_data
    
    def get_energy(self, material, adsorbates, bias, site, ev=True, free_energy=True, proton='smart', reference=True):
        with open(os.path.join(self.path,self.filename),'r') as f: 
            all_data = json.load(f)
        if material in all_data.keys():
            pass
        else:
            raise Exception('Material must match the materials listed in the all_data.json file. '
                            f'{material} was entered which does not match the json')
        
        energy= []
        step = []
        
        if adsorbates == 'all':
            adsorbates = self.reaction_data[self.reaction]['pathway']
        
        if type(site) == int:
            ## If user enters a specific site, calculate energies at that site ##
            for intermediate in adsorbates:
                if intermediate in all_data[material]['adsorbed'].keys() and all_data[material]['adsorbed'][intermediate][f'{bias}V'][f'0{site}']['converged']:
                    energy.append(all_data[material]['adsorbed'][intermediate][f'{bias}V'][f'0{site}']['final_energy'])
                    step.append(f'{intermediate}*')
                else:
                    raise Exception(f'intermediate {intermediate}* at bias {bias}V ' 
                                    f'and site 0{site} on {material} not in all_data.json. '
                                    f'Check to see if it\'s converged')
            energy, step = self.reaction_references(all_data, energy, step, material, 
                                                    adsorbates, bias, site, free_energy, proton) 
        elif site == 'min':
            ## If user enters 'min', search all sites for minimum E value ##
            for intermediate in adsorbates: 
                try:
                    all_data[material]['adsorbed']
                except:
                    raise Exception(f'material {material} has no surface calcs')
                if intermediate in all_data[material]['adsorbed'].keys():
                    E_old = 0
                    E_new = 0
                    for sites in all_data[material]['adsorbed'][intermediate][f'{bias}V'].keys():
                        if all_data[material]['adsorbed'][intermediate][f'{bias}V'][sites]['converged']:
                            E_new = all_data[material]['adsorbed'][intermediate][f'{bias}V'][sites]['final_energy']
                        if E_new < E_old:
                            E_old = E_new
                    if E_old == 0:
                        raise Exception(f'No sites converged for intermediate {intermediate} ' 
                                        f'on material {material} '
                                        f'at bias {bias}.')
                    energy.append(E_old)
                    step.append(f'{intermediate}*')
                else:
                    raise Exception(f'intermediate {intermediate}* at bias {bias}V ' 
                                    f'on {material} not in all_data.json. '
                                    f'Check to see if it\'s converged')
            energy, step = self.reaction_references(all_data, energy, step, material, 
                                                adsorbates, bias, site, free_energy, proton) 
        else:
            raise Exception(f'site must be either an integer or "min." {site} was entered')
        
        if ev:
            energy = list(np.array(energy)*27.2114)
        #Set reference point to final state
        if reference:
            energy = list(np.array(energy)-energy[-1])
        return energy, step
    
    def reaction_references(self, all_data, energies, steps, material, adsorbates, 
                            bias, site, free_energy=True, proton='smart'):
        #start by building initial states for pathway with clean surface and 
        #infinite separation of molecules and protons
        
        #calculated from H3O+ - H2O. Calculation can be found in Cooper's projects/
        #directory /projects/cote3804/proton_energy
        if proton == 'smart': #use solution proton reference
            E_proton = -16.329628244044773 - (-15.910602945824175)
        elif proton == 'stupid':
            E_proton = (1/2) * all_data['H2']['0.00V']['final_energy']
        S_proton = 0.000487715
        # ZPE_proton = 0.013852
        
        #===================================================================#
        #Set up a list of tuples that define the starting and ending state for the
        #reaction. reaction_data is referenced to get the names of molecules and
        #quantity of each molecule for initial and final states. Energies are 
        #created below
        initial_mols = []
        if self.reaction_data[self.reaction]['initial_state']['molecules'] is not None:
            for molecule in self.reaction_data[self.reaction]['initial_state']['molecules']:
                initial_mol_quantity = self.reaction_data[self.reaction]['initial_state']['molecules'][molecule]
                initial_mols.append(tuple([molecule,initial_mol_quantity]))
        else:
            initial_mols = None
        
        final_mols = []
        if self.reaction_data[self.reaction]['final_state']['molecules'] is not None:
            for molecule in self.reaction_data[self.reaction]['final_state']['molecules']:
                final_mol_quantity = self.reaction_data[self.reaction]['final_state']['molecules'][molecule]
                final_mols.append(tuple([molecule,final_mol_quantity]))
        else:
            final_mols = None
            
        #===================================================================#
        #Calculate initial and final state energies
        clean_surf_energy = all_data[material]['surf'][f'{bias}V']['final_energy']
        initial_mol_energy = 0
        final_mol_energy = 0
        if initial_mols is None:
            initial_mol_energy = 0
        else: 
            for molecule,quantity in initial_mols: #looping over both values in tuple list to get molecule names and quantities
                initial_mol_energy += quantity*all_data[molecule][f'{bias}V']['final_energy']
                if free_energy:
                    initial_mol_energy -= quantity * self.reaction_data[self.reaction]['entropy'][molecule]
        if final_mols is None:
            final_mol_energy = 0
        else: 
            for molecule,quantity in final_mols:
                try:
                    final_mol_energy += quantity*all_data[molecule][f'{bias}V']['final_energy']
                except:
                    final_mol_energy += quantity*self.reaction_data['molecules'][molecule][bias]
                if free_energy:
                    final_mol_energy -= quantity * self.reaction_data[self.reaction]['entropy'][molecule]
        
        initial_total_energy = clean_surf_energy + initial_mol_energy + self.reaction_data[self.reaction]['initial_state']['protons'] * E_proton
        final_total_energy = clean_surf_energy + final_mol_energy + self.reaction_data[self.reaction]['final_state']['protons'] * E_proton
        
        
        #===================================================================#
        #Build list of added molecules/proton energies to be added to list of 
        #adsorption energies
        full_pathway = self.reaction_data[self.reaction]['pathway']
        proton_number = self.reaction_data[self.reaction]['protons']
        molecule_dicts = self.reaction_data[self.reaction]['molecules']
        if free_energy:
            entropy = self.reaction_data[self.reaction]['entropy']
        # ZPE = self.reaction_data[self.reaction]['ZPE']
        i = 0
        for adsorbate, energy in zip(steps, energies):
            try:
                path_index = full_pathway.index(adsorbate.split('*')[0])
            except:
                raise ValueError (f'Intermediate {adsorbate} could not be added. '
                                  f'{adsorbate} not found in reaction_data:'
                                  f'\n {self.reaction_data[self.reaction]["pathway"]} \n')
            adsorbate_energy = energy
            proton_energy = proton_number[path_index] * E_proton
            if free_energy:
                proton_energy = proton_energy #+ proton_number[path_index]*(ZPE_proton - S_proton)
                #ZPE and Entropy 
                # proton_energy = proton_energy + proton_number[path_index]*(-S_proton)
            if bool(molecule_dicts[path_index]) is False:
                molecule_energy = 0
            else:
                for molecule in molecule_dicts[path_index].keys():
                    molecule_quantity = molecule_dicts[path_index][molecule]
                    try:
                        molecule_energy = molecule_quantity * all_data[molecule][f'{bias}V']['final_energy']
                    except: #use included values in reaction_data if value not in json
                        molecule_energy = molecule_quantity * self.reaction_data['molecules'][molecule][bias]
                    if free_energy and molecule in entropy.keys():
                        molecule_energy = molecule_energy - molecule_quantity * entropy[molecule]
            
            energies[i] = adsorbate_energy + proton_energy + molecule_energy
            
            i+=1 #index to keep track of which adsorbate we're on
          #==================================================================# 
        energies.insert(0,initial_total_energy) #adding initial state energy to start of list
        energies.append(final_total_energy) #adding final state energy to end of list
         
        steps.insert(0, self.reaction_data[self.reaction]['initial_state']['label']) #labeling final state
        steps.append(self.reaction_data[self.reaction]['final_state']['label']) #labeling initial state
        return energies, steps
        
    def add_pathway(self, material, adsorbates, bias, site, free_energy=True, proton='smart'):
        self.pathways[self.count] = [material, adsorbates, bias, site, free_energy, proton]
        self.count += 1
    
    def pathway_plot(self, ylim=None, legend=True, alpha=1, annotation='plot', custom_colors=None, save_name=None, linestyles=None):
        '''

        Parameters
        ----------
        ylim : TYPE, optional
            DESCRIPTION. The default is None.
        legend : TYPE, optional
            DESCRIPTION. The default is True.
        alpha : TYPE, optional
            DESCRIPTION. The default is 1.
        annotation : string, optional
            Specify where to place the annotation for the reaction intermediates. 
            The options are 'plot' (add annotation on top of last material reaction pathway line) 
            and 'axis' (place on reaction coordinate). Setting to False will remove
            all annotation. The default is 'plot'.
        custom_colors : TYPE, optional
            DESCRIPTION. The default is None.

        Returns
        -------
        None.

        '''
        line_style_guide = ['solid','solid', #style 1 and 2 for horizontal lines
                            'dashed', 'dotted'] #style 1 and 2 for diagonal lines
        
        plt.figure(dpi=300)
        plt.ylabel('$ \Delta \Omega (eV)$')
        plt.xticks([])
        plt.xlabel('Reaction Coordinate')
        plt.gca().spines['right'].set_visible(False) #turn off right border
        # colors = ['#CE3B7E','#E6552E','#9E50F4','#3AC2BC','#ECB42E','#D1DB49']
        if custom_colors is None:
            colors = ['#390099','#9e0059','#ff0054','#ff5400','#ffbd00','#D1DB49']
        else:
            colors = custom_colors
        labels = []
        legend_entries = []
        
        for ipath in range(len(self.pathways.keys())):
            path_list = self.pathways[ipath]
            
            if linestyles is None:
                linestyle = 0
            else:
                linestyle = linestyles[ipath]
            
            #In case there are more reactions to plot than colors in the color
            #pallette, this section loops back through the colors
            loop_number = ipath // len(colors)  if ipath > 0 else 0
            color = colors[ipath-loop_number*len(colors)]

            labels.append(f'{path_list[2]}V')
            energies, steps = self.get_energy(path_list[0],path_list[1],path_list[2],
                                              path_list[3],free_energy=path_list[4],proton=path_list[5])
            #getting the order of reation intermediates. The insert and append lines
            #add the initial and final states to the order. Only add the states if the 
            #psthway order doesn't already have the initial and final state labels in it
            #for example N2R has N2 and NH3 in the pathway which are the initial
            #and final state labels so they aren't added to step_order to avoid duplication
            step_order = self.reaction_data[self.reaction]['pathway'].copy()
            if self.reaction_data[self.reaction]['initial_state']['label'] not in self.reaction_data[self.reaction]['pathway']:
                step_order.insert(0,self.reaction_data[self.reaction]['initial_state']['label']) 
            if self.reaction_data[self.reaction]['initial_state']['label'] not in self.reaction_data[self.reaction]['pathway']:
                step_order.append(self.reaction_data[self.reaction]['final_state']['label']) 
            step_index = 0
            for i,energy in enumerate(energies):
                #logic to determine if there are gaps in reaction steps to 
                #adjust the plot for an abbreviated reaction pathway
                step = steps[i].split('*')[0]
                new_step_index = step_order.index(step)
                if new_step_index >= step_index +2:
                    step_index = new_step_index
                    #Just draw horizontal lines instead of adding dotted lines
                    #and annotate
                    plt.hlines(energy, i, i+0.5, color=color, label=labels[ipath],
                               alpha=alpha, linestyle=line_style_guide[linestyle])
                    if ipath == len(self.pathways.keys())-1 and annotation == 'plot': #only annotate last pathway
                        plt.annotate(steps[i], ((i+0),energy+0.1), color=color)
                    continue
                else:
                    #continue to normal plotting logic below if the current step
                    #is not separated by a gap in the reaction path from the previous
                    #step
                    step_index = new_step_index
                    pass
                plt.hlines(energy, i, i+0.5, color=color, label=labels[ipath],
                           alpha=alpha, linestyle=line_style_guide[linestyle])
                if i > 0:
                    plt.plot([i,i-0.5], [energies[i],energies[i-1]], color=color, label=labels[ipath],
                             alpha=alpha, linestyle=line_style_guide[linestyle+2])
                if ipath == len(self.pathways.keys())-1 and annotation=='plot': #only annotate last pathway
                    plt.annotate(steps[i], ((i+0.2),energy+0.1), color=color)
            #Create legend entry objects
            free_energy_term = 'free energy' if path_list[4] else 'enthalpy'
            legend_entries.append(Line2D([0], [0], 
                                         color=color, lw=2,
                                         # label=f'{path_list[0].split("_")[0]} ({path_list[0].split("_")[1]}) {labels[ipath]} {free_energy_term}')
                                  # label=f'{path_list[0].split("_")[0]} ({path_list[0].split("_")[1]})',
                                   label=f'{path_list[0].split("_")[0]}',
                                  linestyle = line_style_guide[linestyle*3])
                                  )
        if annotation == 'axis':
            #create array from 0 to the number of steps in the pathway. 0.25
            #is added to place ticks in the middle of the step horizontal lines
            #because they are 0.5 units wide
            ticks = []
            for i in range(len(steps)):
                if i == 0:
                    ticks.append(0.25)
                    continue
                else:
                    ticks.append(i + 0.25)
            plt.xticks(ticks=ticks,labels=steps, fontsize=8)
        if legend:
            plt.legend(handles=legend_entries, fontsize=9, frameon=False, bbox_to_anchor=(1.15, 1))
        else:
            pass
        
        if ylim is None:
            pass
        else:
            plt.ylim(ylim)
        
        if save_name is not None:
            plt.savefig(os.path.join(self.path,save_name))
        
    def energies(self,ev=True, reference=True):
        energies_dict = {}
        for ipath in range(len(self.pathways.keys())):
            path_list = self.pathways[ipath]
            #calculate energies and create list of intermediates using the parameters
            #added by add_pathway().
            energies, steps = self.get_energy(path_list[0],path_list[1],path_list[2],path_list[3],
                                              free_energy=path_list[4],ev=ev,proton=path_list[5],reference=reference)
            energy_dict = {}
            for i,energy in enumerate(energies):
                energy_dict[steps[i]] = energy
            energies_dict[path_list[0]] = energy_dict
        return energies_dict
    
    def get_adatom_energies(self, ev=True):
        H_to_ev = 27.2114
        E_proton = -16.329628244044773 - (-15.910602945824175)
        adatom = 'N'
        parameters_list = []
        adatom_energies = {}
        all_data = self.get_json()
        for ipath in range(len(self.pathways.keys())):
            path_list = self.pathways[ipath]
            #get material, bias, site and free energy setting from parameters 
            #input by user in add_pathway()
            parameters_list.append(tuple([path_list[0], path_list[2], path_list[3], path_list[4]]))
        #adatom energy calcualted as: N* - surface - 1/2(N2)
        for material, bias, site, free_energy in parameters_list:
            molecular_energy = (0.5*all_data['N2'][f'{bias}V']['final_energy'])
            if type(site) is int:
                adsorbate_energy = all_data[material]['adsorbed'][adatom][f'{bias}V'][f'0{site}']['final_energy'] #adsorbate complex
            elif site == 'min': #search through all sites to find lowest energy configuration
                E_old = 0
                for sites in all_data[material]['adsorbed'][f'{adatom}'][f'{bias}V'].keys():
                    if all_data[material]['adsorbed'][f'{adatom}'][f'{bias}V'][sites]['converged']:
                        E_new = all_data[material]['adsorbed'][f'{adatom}'][f'{bias}V'][sites]['final_energy']
                    if E_new < E_old:
                        E_old = E_new
                adsorbate_energy = E_old
            surface_energy = all_data[material]['surf'][f'{bias}V']['final_energy']
            adatom_energy = adsorbate_energy - (surface_energy + molecular_energy)
            adatom_energies[material] = adatom_energy
            if ev:
                adatom_energies[material] = adatom_energy * H_to_ev
        #TODO add support beyond N2R
            
        return adatom_energies
    
    def get_limiting_energies(self):
        sort_order = ['N2','N2*','N2H*','NNH2*','NNH3*','N*','NH*','NH2*','NH3*','2NH3']
        energies = self.energies()
        
        #build reaction order from energies
        materials = [x for x in energies.keys()]

        limiting_energies = {}
        for material in energies.keys():
            i = 0
            reaction_order = []
            for step in energies[material].keys():
            #build reaction order from energies
                reaction_order.append(step)
            step_energy = 0 #start at zero for comparison logic
            limiting_energies[material] = {}
            for intermediate in energies[material]:
                energy = energies[material][intermediate]
                order_index = reaction_order.index(intermediate)
                try:
                    next_intermediate = reaction_order[order_index + 1]
                except:
                    continue
                next_energy = energies[material][next_intermediate]
                energy_change = next_energy - energy
                
                #logic to find maximum energy change between intermediates and store 
                #highest value in step_energy
                if energy_change > step_energy:
                    step_energy = energy_change 
                    key_string = f'{intermediate} -> {next_intermediate}'
            limiting_energies[material] = tuple([key_string,step_energy])
        return limiting_energies
    
    def get_step_energy(self,intermediate_names,step_label=None):
        try:
            react1 = intermediate_names[0]
            react2 = intermediate_names[-1]
        except:
            raise Exception('intermediate_names must be a list or tuple of length 2')
        if step_label == None:
            step_label = intermediate_names[-1]
        
        materials = self.get_materials()
        energies = self.energies()
        state_1_energies = {}
        for material in materials:
            state_1_energies[material] = energies[material][react2] - energies[material][react1]
        
        return state_1_energies
        
    
if __name__ == '__main__':
    #place test code below
    file = 'combined_N2R_all_data.json'
    path = os.path.normpath('C:\\Users\\coopy\\OneDrive - UCB-O365\\Research\\N2R_Scaling')
    material = 'Ru_111'
    
    dissociative_pathway = Pathway(path=path, filename=file, reaction='N2R_dissociative')
    dissociative_pathway.add_pathway(material ,['N','NH','NH2','NH3'],'0.00','min',free_energy=True)
    dissociative_energies = dissociative_pathway.energies(ev=False,reference=False)[material]