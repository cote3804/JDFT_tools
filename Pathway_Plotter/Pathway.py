# -*- coding: utf-8 -*-
"""
Created on Wed Jul  6 12:50:59 2022

@author: coopy
"""
#This script provides the functionality to parse through the all_data.json 
#file generated by gc_manager and plot desired energy pathways using 
#matplotlib

###############################################################################
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
from matplotlib.patches import Patch
import numpy as np
import json
import os
import re
import pprint
H_to_ev = 27.2114

###############################################################################
# with open(os.path.join(path,json_file),'r') as f:
#     all_data = json.load(f)

class Pathway:
    def __init__(self, path=None, filename=None, reaction='N2R'):
        if path is None:
            self.path = os.getcwd()
        else:
            self.path = path
            
        if filename is None:
            self.filename = 'all_data.json'
        else:
            self.filename = filename
        self.pathways = {}
        self.count = 0
        self.reaction = reaction
        self.reaction_data = {
                            'N2R': 
                          {'pathway' : ['N2','N2H','NNH2','NNH3','N','NH','NH2','NH3'],
                          'protons' : [6, 5, 4, 3, 3, 2, 1, 0],
                          'molecules' : [{},{},{},{},{'NH3':1},{'NH3':1},{'NH3':1},{'NH3':1}],
                          'entropy' : {'N2': 0.021720172, 'NH3': 0.021830347, 
                                       'H3O': 0.021892558, 'H2O': 0.021404843},
                          'ZPE' : {'N2': 0.005677, 'NH3': 0.034492, 
                                       'H3O': 0.035438, 'H2O': 0.021586 },
                          'initial_state' : {'molecules' : {'N2' : 1},
                                             'protons' : 6,
                                             'label' : 'N2'},
                          'final_state' : {'molecules' : {'NH3' : 2},
                                             'protons' : 0,
                                             'label': '2NH3'}
                              },
                          
            
                            'HER':
                          {'pathway' : ['H'],
                           'protons' : [1],
                           'molecules' : [['']],
                           'entropy' : {'H3O': 0.035438, 'H2O': 0.021586,
                                        'H2': 0.014789719},
                           'ZPE' : {'H3O': 0.035438, 'H2O': 0.021586,
                                    'H2': 0.010088},
                           'initial_state' : {'molecules' : None,
                                              'protons' : 2,
                                              'label' : '$2H^+$'},
                           'final_state' : {'molecules' : {'H2' : 1},
                                              'protons' : 0,
                                              'label' : '$H_2$'}
                           },
                          
                          'CO2R':
                              {'pathway' : ['CO2','COOH','CO'],
                               'protons' : [2,1,0],
                               'molecules' : [{}, {}, {'H2O':1}],
                               'initial_state' : {'molecules' : {'CO2' : 1},
                                                  'protons' : 2,
                                                  'label' : 'CO2 (aq)'},
                               'final_state' : {'molecules' : {'H2O' : 1, 'CO' : 1},
                                                  'protons' : 0,
                                                  'label' : 'CO (aq)'},
                                  
                                  }
                             
            
            
            }
        self.potentials = {'0.00': -0.1713, '-0.25': -0.1621, '-0.50': -0.1529}
        
    def set_reaction_data(self, reaction_data_entry, reaction_name):
        self.reaction_data[reaction_name] = reaction_data_entry
        
        
    def get_reaction_data(self):
        pprint.pprint(self.reaction_data)
        
    def get_json(self):
        '''
        This method will return the json as a dictionary to be investigated in 
        the IDE variable pane
        '''
        with open(os.path.join(self.path,self.filename),'r') as f:
            all_data = json.load(f)
        return all_data
    
    def get_energy(self, material, adsorbates, bias, site, ev=True, free_energy=True, proton='smart'):
        with open(os.path.join(self.path,self.filename),'r') as f:
            all_data = json.load(f)
        if material in all_data.keys():
            pass
        else:
            raise Exception('Material must match the materials listed in the all_data.json file. '
                            f'{material} was entered which does not match the json')
        
        energy= []
        step = []
        for intermediate in adsorbates: 
            if intermediate in all_data[material]['adsorbed'].keys() and all_data[material]['adsorbed'][intermediate][f'{bias}V'][f'0{site}']['converged']:
                energy.append(all_data[material]['adsorbed'][intermediate][f'{bias}V'][f'0{site}']['final_energy'])
                step.append(f'{intermediate}*')
            else:
                raise Exception(f'intermediate {intermediate}* at bias {bias}V ' 
                                f'and site 0{site} on {material} not in all_data.json. '
                                f'Check to see if it\'s converged')
        energy, step = self.reaction_references(all_data, energy, step, material, 
                                                adsorbates, bias, site, free_energy, proton)        
        if ev:
            energy = list(np.array(energy)*27.2114)
        #Set reference point to final state
        energy = list(np.array(energy)-energy[-1])
        return energy, step
    
    def reaction_references(self, all_data, energies, steps, material, adsorbates, 
                            bias, site, free_energy=True, proton='smart'):
        #start by building initial states for pathway with clean surface and 
        #infinite separation of molecules and protons
        
        #calculated from H3O+ - H2O. Calculation can be found in Cooper's projects/
        #directory /projects/cote3804/proton_energy
        if proton == 'smart': #use solution proton reference
            E_proton = -17.7048336646746769 - (-17.2809934718248783) 
        elif proton == 'stupid':
            E_proton = (1/2) * all_data['H2'][f'{bias}V']['final_energy']
        S_proton = 0.000487715
        ZPE_proton = 0.013852
        
        #===================================================================#
        #Set up a list of tuples that define the starting and ending state for the
        #reaction. reaction_data is referenced to get the names of molecules and
        #quantity of each molecule for initial and final states. Energies are 
        #created below
        initial_mols = []
        if self.reaction_data[self.reaction]['initial_state']['molecules'] is not None:
            for molecule in self.reaction_data[self.reaction]['initial_state']['molecules']:
                initial_mol_quantity = self.reaction_data[self.reaction]['initial_state']['molecules'][molecule]
                initial_mols.append(tuple([molecule,initial_mol_quantity]))
        else:
            initial_mols = None
        
        final_mols = []
        if self.reaction_data[self.reaction]['final_state']['molecules'] is not None:
            for molecule in self.reaction_data[self.reaction]['final_state']['molecules']:
                final_mol_quantity = self.reaction_data[self.reaction]['final_state']['molecules'][molecule]
                final_mols.append(tuple([molecule,final_mol_quantity]))
        else:
            final_mols = None
            
        #===================================================================#
        #Calculate initial and final state energies
        clean_surf_energy = all_data[material]['surf'][f'{bias}V']['final_energy']
        initial_mol_energy = 0
        final_mol_energy = 0
        if initial_mols is None:
            initial_mol_energy = 0
        else: 
            for molecule,quantity in initial_mols: #looping over both values in tuple list to get molecule names and quantities
                initial_mol_energy += quantity*all_data[molecule][f'{bias}V']['final_energy']
                if free_energy:
                    initial_mol_energy -= quantity * self.reaction_data['entropy'][molecule]
        if final_mols is None:
            final_mol_energy = 0
        else: 
            for molecule,quantity in final_mols:
                final_mol_energy += quantity*all_data[molecule][f'{bias}V']['final_energy']
                if free_energy:
                    initial_mol_energy -= quantity * self.reaction_data['entropy'][molecule]
        
        initial_total_energy = clean_surf_energy + initial_mol_energy + self.reaction_data[self.reaction]['initial_state']['protons'] * E_proton
        final_total_energy = clean_surf_energy + final_mol_energy + self.reaction_data[self.reaction]['final_state']['protons'] * E_proton
        
        
        #===================================================================#
        #Build list of added molecules/proton energies to be added to list of 
        #adsorption energies
        full_pathway = self.reaction_data[self.reaction]['pathway']
        proton_number = self.reaction_data[self.reaction]['protons']
        molecule_dicts = self.reaction_data[self.reaction]['molecules']
        if free_energy:
            entropy = self.reaction_data[self.reaction]['entropy']
        # ZPE = self.reaction_data[self.reaction]['ZPE']
        i = 0
        for adsorbate, energy in zip(steps, energies):
            try:
                path_index = full_pathway.index(adsorbate.split('*')[0])
            except:
                raise ValueError (f'Intermediate {adsorbate} could not be added. '
                                  f'{adsorbate} not found in reaction_data:'
                                  f'\n {self.reaction_data[self.reaction]["pathway"]} \n')
            adsorbate_energy = energy
            proton_energy = proton_number[path_index] * E_proton
            if free_energy:
                proton_energy = proton_energy + proton_number[path_index]*(ZPE_proton - S_proton)
                #ZPE and Entropy 
                # proton_energy = proton_energy + proton_number[path_index]*(-S_proton)
            if bool(molecule_dicts[path_index]) is False:
                molecule_energy = 0
            else:
                for molecule in molecule_dicts[path_index].keys():
                    molecule_quantity = molecule_dicts[path_index][molecule]
                    molecule_energy = molecule_quantity * all_data[molecule][f'{bias}V']['final_energy']
                    if free_energy and molecule in entropy.keys():
                        # molecule_energy = molecule_energy + molecule_quantity*(ZPE[molecule] - entropy[molecule])
                        #ZPE and Entropy
                        molecule_energy = molecule_energy - molecule_quantity * entropy[molecule]
                        #Entropy alone
                        #TODO decide whether or not to implement ZPE
            energies[i] = adsorbate_energy + proton_energy + molecule_energy
            i+=1
          #==================================================================# 
        energies.insert(0,initial_total_energy)
        energies.append(final_total_energy)
         
        steps.insert(0, self.reaction_data[self.reaction]['initial_state']['label'])
        steps.append(self.reaction_data[self.reaction]['final_state']['label'])
        return energies, steps
        
    def add_pathway(self, material, adsorbates, bias, site, free_energy=True, proton='smart'):
        self.pathways[self.count] = [material, adsorbates, bias, site, free_energy, proton]
        self.count += 1
    
    def pathway_plot(self, ylim=None, legend=True, alpha=1, annotation=True, custom_colors=None):
        plt.figure(dpi=300)
        plt.ylabel('$\Delta \Phi (eV)$')
        plt.xticks([])
        plt.xlabel('Reaction Coordinate')
        # colors = ['#CE3B7E','#E6552E','#9E50F4','#3AC2BC','#ECB42E','#D1DB49']
        if custom_colors is None:
            colors = ['#390099','#9e0059','#ff0054','#ff5400','#ffbd00','#D1DB49']
        else:
            colors = custom_colors
        labels = []
        legend_entries = []

        for ipath in range(len(self.pathways.keys())):
            path_list = self.pathways[ipath]
            color = colors[ipath]
            labels.append(f'{path_list[2]}V')
            energies, steps = self.get_energy(path_list[0],path_list[1],path_list[2],
                                              path_list[3],free_energy=path_list[4],proton=path_list[5])
            for i,energy in enumerate(energies):
                plt.hlines(energy, i, i+0.5, color=color, label=labels[ipath],
                           alpha=alpha)
                if i > 0:
                    plt.plot([i,i-0.5], [energies[i],energies[i-1]], linestyle='--', color=color, label=labels[ipath],
                             alpha=alpha)
                if ipath == len(self.pathways.keys())-1 and annotation: #only annotate last pathway
                    plt.annotate(steps[i], ((i+0),energy+0.1), color=color)
            #Create legend entry objects 
            free_energy_term = 'free energy' if path_list[4] else 'enthalpy'
            legend_entries.append(Line2D([0], [0], 
                                         color=colors[ipath], lw=2,
                                         label=f'{path_list[0]} {labels[ipath]} {free_energy_term}'))
        if legend:
            plt.legend(handles=legend_entries, fontsize=6)
        else:
            pass
        
        if ylim is None:
            pass
        else:
            plt.ylim(ylim)
        plt.savefig(os.path.join(self.path,'N2R_Pathway_0V'))
        
    def energies(self,ev=True):
        energies_dict = {}
        for ipath in range(len(self.pathways.keys())):
            path_list = self.pathways[ipath]
            energies, steps = self.get_energy(path_list[0],path_list[1],path_list[2],path_list[3],
                                              free_energy=path_list[4],ev=ev,proton=path_list[5])
            energy_dict = {}
            for i,energy in enumerate(energies):
                energy_dict[steps[i]] = energy
            energies_dict[path_list[0]] = energy_dict
        return energies_dict
    
    def adatom_energy(self, all_data, material, site, bias='0.00', ev=True):
        H_to_ev = 27.2114
        E_proton = -17.7048336646746769 - (-17.2809934718248783)
        if self.reaction == 'N2R':
            adatom= 'N'
        else:
            pass
        #TODO add more reaction support
        molecular_energy = (all_data['N2'][f'{bias}V']['final_energy'] #N2 molecule
                            +3*E_proton) #3 protons
        adsorbate_energy = (all_data[material]['adsorbed'][adatom][f'{bias}V'][f'0{site}']['final_energy'] #adsorbate complex
                            + all_data['NH3'][f'{bias}V']['final_energy'])
        surface_energy = all_data[material]['surf'][f'{bias}V']['final_energy']
        adatom_energy = adsorbate_energy - (surface_energy + molecular_energy)
        
        if ev:
            adatom_energy = adatom_energy * H_to_ev
        return adatom_energy
    
    
if __name__ == '__main__':
    
    my_file = 'all_data.json'
    my_path = 'C:\\Users\\coopy\\OneDrive - UCB-O365\\Research\\N2R_Scaling'
    with open(os.path.join(my_path,my_file),'r') as f:
        my_data = json.load(f)
        
    aziz_path = os.path.normpath('C:\\Users\\coopy\\Downloads')
    aziz_file = 'pyrrolic.json'
    with open(os.path.join(aziz_path,aziz_file),'r') as f:
        aziz_data = json.load(f)

    new_dict = my_data | aziz_data 
    with open(os.path.join(aziz_path,'new_json.json'),'w') as f:
        aziz_data = json.dump(new_dict, f)
    
    # f1data = f2data = "" 
     
    # with open(os.path.join(my_path,my_file)) as f1: 
    #   f1data = f1.read() 
    # with open(os.path.join(aziz_path,aziz_file)) as f2: 
    #   f2data = f2.read() 
     
    # f1data += f2data
    # with open (os.path.join(aziz_path,'new_json.json'), 'a') as f3: 
    #   f3.write(f1data)
    
    pathway = Pathway(path=aziz_path, filename='new_json.json', reaction='CO2R')
    all_data = pathway.get_json()
    # pathway.get_reaction_data()
    pathway.add_pathway('Fe',['CO2','COOH','CO'],'-0.50',1,free_energy=False)
    pathway.add_pathway('Ti',['CO2','COOH','CO'],'-0.50',1,free_energy=False)
    pathway.add_pathway('Ni',['CO2','COOH','CO'],'-0.50',1,free_energy=False)
    pathway.pathway_plot()
    # pathway.add_pathway('Ru_111',['N2','N2H','NH3'],'0.00',1,free_energy=False)
    # pathway.add_pathway('Ir_111',['N2','N2H','NH3'],'0.00',1,free_energy=False)
    # pathway.add_pathway('Co_111_mag',['N2','N2H','NH3'],'0.00',1,free_energy=False)
    # # pathway.add_pathway('F_110',['N2','N2H','NNH2','NNH3','N','NH','NH2','NH3'],'0.00',1,free_energy=False)
    
    energies = pathway.energies()
    # pathway.pathway_plot()

